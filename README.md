



# C# 在Winfrom中引入WebApi和异步编程

> ​	在当今的软件开发领域，提升用户体验是至关重要的。本C#大作业将探索如何在Winform应用程序中融合Web API和异步编程，以此来提高应用程序的性能和用户界面的响应性。通过采用异步编程，我们能够在不阻塞UI线程的同时，有效地处理I/O密集型任务或在后台线程中执行CPU密集型任务。这种方法不仅提高了程序的效率，还符合人体工程学原则，使得用户界面更加友好。
> 	同时，集成Web API使得应用程序能够与远程服务器进行灵活的交互，无需关注底层数据库模型。这种解耦合的设计允许开发者通过调用公开接口来获取所需的数据和服务，从而简化了开发流程。综合运用这些先进技术，我们的Winform应用程序将变得更加强大和灵活，能够高效地处理复杂的数据操作，同时确保用户界面的高响应性和良好的交互体验。这不仅提升了用户满意度，也为可能为Winform软件开发树立了新的标杆。



## 一、系统描述

>  实现一个demo，完成CRUD的基本API调用和异步编程	

###  1、用户管理

 调用前期已经写好的基于MVC架构和ASP.NET Core7.0 WebApi的接口，对用户实现查询功能。即需要实现：

- 用户信息查询（登录）
- 用户注册（增加）



![Swagger](https://github.com/177-Liukuan/winform-WebAPI-asynchronous/blob/master/%E5%A4%A7%E4%BD%9C%E4%B8%9A/img/%E5%9B%BE%E7%89%871.png)



### 2、天气查询

调用从高德开放平台申请的天气API，查询近几日天气。

![高德开放平台](https://github.com/177-Liukuan/winform-WebAPI-asynchronous/blob/master/%E5%A4%A7%E4%BD%9C%E4%B8%9A/img/%E5%9B%BE%E7%89%872.png)

### 3.一种实现窗体/控件布局缩放自适应的简洁方法

使用第三方提供的程序集，只需要几行代码就可以实现效果良好的窗体/控件布局缩放自适应。

Gitee地址：https://gitee.com/hu-lizhe/AutoScaleHelper

## 二、系统架构

### 1.异步编程架构（总结C#官方文档）

#### （1）程序控制流图

![asynchronous](https://github.com/177-Liukuan/winform-WebAPI-asynchronous/blob/master/%E5%A4%A7%E4%BD%9C%E4%B8%9A/img/%E5%9B%BE%E7%89%873.png)





#### （2）异步编程前置知识：

进程：CPU（处理机）分配资源的最小单位
线程：CPU处理任务的最小单位
进程与线程的关系：
进程同步：多个进程上处理机运行具有顺序关系，前一个执行了后一个才能执行
进程互斥：某些资源同一时间只允许一个进程使用
I/O密集型任务：如打印机打印、网络I/O、磁盘I/O，任务的瓶颈是I/O系统的速度
CPU密集型任务：如复杂的数学计算、加密算法，任务的瓶颈是CPU的计算能力
C#中异步编程的三个主要对象：

  - async：用于声明当前函数是一个异步函数
  - await：用于标记异步函数的暂停点，只能在async声明的函数中使用
  - Task或Task<>：一个异步操作的类，用于执行异步操作

#### （3）异步编程的参考示例：

- IO密集型任务：这类任务通常涉及到文件读写、数据库操作、网络请求等，这些操作的特点是等待时间长，但CPU计算量小。在.NET中，我们通常使用async和await关键字来处理这类任务。

```csharp
public async Task<string> ReadFileAsync(string filePath)

{

    using (StreamReader reader = File.OpenText(filePath))

    {

        string content = await reader.ReadToEndAsync();

        return content;

    }

}

```

在上述代码中，ReadToEndAsync方法是一个异步方法，它会在读取文件内容时释放CPU，允许其他任务继续执行。当文件内容读取完成后，它会返回一个Task<string>，表示一个异步操作的结果。

- CPU密集型任务：这类任务通常涉及到大量的计算，如图像处理、机器学习等。在.NET中，我们通常使用Task.Run方法来在后台线程中执行这类任务。

```csharp
public async Task<int> CalculateSumAsync(int[] numbers)

{

    return await Task.Run(() =>

    {

        int sum = 0;

        for (int i = 0; i < numbers.Length; i++)

        {

            sum += numbers[i];

        }

        return sum;

    });

}

```



在上述代码中，Task.Run方法会在一个后台线程中执行传入的委托。这样，即使委托中的代码需要大量的CPU时间来执行，也不会阻塞主线程。当计算完成后，它会返回一个Task<int>，表示一个异步操作的结果。



### 2.调用WebApi的架构（根据开发经历设计的）

![winform调用API架构](https://github.com/177-Liukuan/winform-WebAPI-asynchronous/blob/master/%E5%A4%A7%E4%BD%9C%E4%B8%9A/img/%E5%9B%BE%E7%89%874.png)



假如是我仅是一个winform开发人员，为了正确调用API进行JSON数据反序列化，我还需要从后端获取API的接收格式，在这里，我自定义了本系统的前后端程序的数据格式ApiResult和ApiDataResult：

```csharp
using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Commons

{

    /// <summary>

    /// Api  JSON通用返回格式

    /// </summary>

    public class ApiResult

    {

        /// <summary>

        /// 是否正常返回

        /// </summary>

        public bool Success { get; set; }

        /// <summary>

        /// 处理消息

        /// </summary>

        public string? Message { get; set; }

    }

    public class ApiDataResult<T> : ApiResult

    {

        /// <summary>

        /// 结果集

        /// </summary>

        public T? Data { get; set; }

        /// <summary>

        /// 冗余结果

        /// </summary>

        public object? OValue { get; set; }

    }

}

```

我在从WebAPI中获取数据主页使用上面的泛型模板。



## 三、代码功能与核心代码

#### 1.用户登录.cs设计说明：

该类是一个窗体应用程序，用于进行登录操作。以下是该类的设计说明：

（1）异步编程对象引入： 该类利用了异步编程技术，通过async和await关键字以及Task<>对象实现了异步方法调用，例如checkUserAsync方法。这些异步操作主要用于网络请求和IO密集型操作，以避免UI线程阻塞，提高程序的响应速度和并发性能。
（2）网络请求和数据处理： 通过HttpClient类实现了与后端API的通信，使用了PostAsync方法发送POST请求并异步获取响应数据。利用Newtonsoft.Json库对JSON格式的响应数据进行反序列化，并通过异步方法处理和解析数据，最终实现了用户信息的验证和处理。
（3）错误处理和用户提示： 该类在用户登录过程中实现了错误次数的计数和处理，当用户连续输入错误达到一定次数时，禁止用户登录按钮的点击，并在一段时间后恢复按钮的可用状态。同时，通过消息框向用户提示登录结果和错误信息，提高了用户体验和程序的友好性。
（3）界面交互和事件处理： 通过事件处理方法，实现了用户输入框的焦点切换、按钮点击事件的处理以及界面元素的更新和交互。例如，在用户输入完成后按下回车键，自动将焦点切换到下一个输入框；在天气预报部分，利用按钮点击事件实现了天气预报详情的切换和更新。
（4）界面布局和自适应设计： 通过自定义的AutoScale类实现了界面元素的自适应布局，使得窗体大小的变化不会影响界面元素的显示和排列。在窗体加载和大小改变事件中调用了自适应布局的方法，保证了界面的美观和一致性。




#### 2. 天气预测.cs设计说明：
该类用于解析和处理天气预报数据，主要包括以下功能和设计：

（1）JSON数据反序列化：利用Newtonsoft.Json库的JsonProperty特性，将JSON格式的天气预报数据反序列化为C#对象。通过定义与JSON属性对应的类成员，实现了数据的映射和解析。
（2）数据模型设计：该类定义了三个数据模型，分别对应于不同层级的天气预报数据结构。天气预报类（天气预报.cs）包含了总体的预报信息，包括状态、数量、信息代码等。预报类（预报.cs）包含了具体城市的预报信息，包括城市名称、行政编码、省份等。天气预测类（天气预测.cs）包含了每日的具体天气预测信息，包括日期、星期、白天天气等。
（3）数据结构嵌套：通过在数据模型中定义嵌套的数据结构，实现了对复杂JSON数据的解析和处理。例如，预报类中包含了一个天气预测列表，用于存储每日的具体预测信息。
（4）属性映射和命名规范：利用JsonProperty特性，将C#类成员与JSON属性进行映射，确保了数据的正确解析和对应关系的一致性。同时，采用了清晰的命名规范，使得代码易于理解和维护。

#### 3.药品实体.cs设计说明：

该类用于描述和处理药品相关的数据，主要包括以下功能和设计：

（1）数据模型设计：该类定义了一个数据模型，对应于药品的各种属性。药品实体类（药品实体.cs）包含了药品的各种信息，包括药品ID、药品名称、批准文号、OTC标识、成分、性状、功能、规格、使用方法、不良反应、警告、药物相互作用、药理作用、有效期、保存方法、批准单位、创建时间、修改时间、状态和信息录入者等。
（2）属性设计：每个属性都有一个`get`和`set`访问器，用于获取或设置属性的值。例如，`药品ID`属性用于获取或设置药品的ID，`药品名称`属性用于获取或设置药品的名称。
（3）可空类型：一些属性使用了可空类型（`?`），这意味着这些属性可以被赋值为`null`。例如，`药品名称`、`批准文号`、`OTC`、`成分`、`性状`、`功能`、`规格`、`使用方法`、`不良反应`、`警告`、`药物相互作用`、`药理作用`、`有效期`、`保存`、`批准`、`创建时间`、`修改时间`和`状态`等属性都可以被赋值为`null`。
（4）命名规范：所有的属性都采用了清晰的命名规范，使得代码易于理解和维护。例如，`药品ID`属性用于表示药品的ID，`药品名称`属性用于表示药品的名称。

#### 4.用户实体.cs设计说明： 

该类用于描述和处理用户相关的数据，主要包括以下功能和设计：
（1）数据模型设计：该类定义了一个数据模型，对应于用户的各种属性。用户实体类（用户实体.cs）包含了用户的各种信息，包括系统用户ID、用户名、密码、手机号、邮箱、性别、年龄、头像URL、注册时刻、最后登录时刻、状态、其他、角色ID和WeChatOpenID等。
（2）属性设计：每个属性都有一个get和set访问器，用于获取或设置属性的值。例如，系统用户ID属性用于获取或设置用户的系统ID，用户名属性用于获取或设置用户的名称。
（3）可空类型：一些属性使用了可空类型（?），这意味着这些属性可以被赋值为null。例如，用户名、密码、手机号、邮箱、性别、年龄、头像URL、注册时刻、最后登录时刻、状态、其他、角色ID和WeChatOpenID等属性都可以被赋值为null。
（4）命名规范：所有的属性都采用了清晰的命名规范，使得代码易于理解和维护。例如，系统用户ID属性用于表示用户的系统ID，用户名属性用于表示用户的名称。

#### 5.主页.cs设计说明： 

该类是一个窗体应用程序，用于进行各种操作。以下是该类的设计说明：
（1）异步编程对象引入：该类利用了异步编程技术，通过async和await关键字以及Task<>对象实现了异步方法调用，例如button1_Click方法。这些异步操作主要用于网络请求和IO密集型操作，以避免UI线程阻塞，提高程序的响应速度和并发性能。
（2）网络请求和数据处理：通过HttpClient类实现了与后端API的通信，使用了GetAsync方法发送GET请求并异步获取响应数据。利用Newtonsoft.Json库对JSON格式的响应数据进行反序列化，并通过异步方法处理和解析数据，最终实现了药品信息的获取和处理。
（3）数据绑定和显示：该类在获取到药品信息后，将数据绑定到dataGridView1，实现了数据的动态显示。同时，通过消息框向用户提示相关信息，提高了用户体验和程序的友好性。
（4）界面交互和事件处理：通过事件处理方法，实现了按钮点击事件的处理以及界面元素的更新和交互。例如，在点击button1后，会发送网络请求并获取药品信息；在点击button2后，会弹出消息框进行提示。
（5）界面布局和自适应设计：通过Form类和其相关方法，实现了界面元素的布局和自适应设计。在窗体加载和大小改变事件中，保证了界面的美观和一致性。

#### 6. Register.cs设计说明：
该类是一个窗体应用程序，用于实现用户注册功能。以下是该类的设计说明：
（1）异步编程对象引入：该类利用了异步编程技术，通过async和await关键字以及Task<>对象实现了异步方法调用。例如，在点击注册按钮时，调用了异步方法PostAsync发送POST请求并异步获取响应数据，以避免UI线程阻塞，提高程序的响应速度和并发性能。
（2）网络请求和数据处理：通过HttpClient类实现了与后端API的通信，使用了PostAsync方法发送POST请求并异步获取响应数据。利用Newtonsoft.Json库对JSON格式的响应数据进行反序列化，并通过异步方法处理和解析数据，最终实现了将用户注册信息录入数据库的功能。
（3）界面交互和事件处理：注册界面实现了拖放功能，用户可以通过拖放图片文件进行头像选择。利用Panel_DragEnter和Panel_DragDrop事件处理拖放操作，将拖放的图片文件路径存储在filePath变量中，并将图片显示在Panel上。另外，通过按钮点击事件清空所有输入框中的文本、显示和隐藏控件等，提高了用户体验
（4）错误处理和用户提示：注册过程中，对网络请求和异常进行了适当的错误处理和用户提示。例如，当注册失败时，通过消息框向用户显示注册失败的提示信息，增强了程序的健壮性和用户友好性。
（5）界面布局和自适应设计：通过自定义的AutoScale类实现了界面元素的自适应布局，保证了注册界面在不同窗体大小下的良好显示效果。在窗体加载和大小改变事件中调用了自适应布局的方法，保证了界面的一致性和美观性。



## 四、总结

本大作业的核心内容包括异步编程的使用、WebAPI的集成、用户管理、天气查询的实现以及窗体/控件布局的自适应，但仍然存在待改进的地方：

1. 异步编程：可以更深入地理解和掌握异步编程的原理和技巧，例如如何处理异步操作的异常，如何使用CancellationToken来取消异步操作等；
2. WebAPI的集成：可以考虑如何处理网络异常，如何保护用户的隐私和数据安全，以及如何优化网络请求的性能等问题；
3. 业务功能的集成：可以补充完善更多的业务，如用户管理的CRUD、药品管理的CRUD等

五、参考资料
[Asynchronous programming in C# - C# | Microsoft Learn]( [Asynchronous programming in C# - C# | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/asynchronous-programming/) )

[开发 | 高德地图API (amap.com)]( [开发 | 高德地图API (amap.com)](https://lbs.amap.com/api) )
